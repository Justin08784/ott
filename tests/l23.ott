% examples/tapl/nat.ott was an 'inspiration'

metavar var, x ::=   {{ com  term variable }} 
{{ isa string}} {{ coq nat}} {{ hol string}} {{ lem string }} {{ coq-equality }}
{{ ocaml int}} {{ lex alphanum}} {{ tex \mathit{[[var]]} }}



grammar
t :: Tm ::=                                       {{ com terms: }}
| ( t )                      :: M :: Paren      {{ ich [[t]] }}
| 0                          ::   :: Zero       {{ com constant zero }}
| S t                        ::   :: Succ       {{ com successor }}
| P t                        ::   :: Pred       {{ com predeccessor }}
| iszero t                   ::   :: Iszero     {{ com zero test }}
| iseven t                   ::   :: Iseven     {{ com even test }}
| T                          ::   :: True       {{ com constant zero }}
| F                          ::   :: False      {{ com constant zero }}
| t1 ? t2 : t3               ::   :: Cond       {{ com conditional }}
| not t                      ::   :: Not        {{ com not }}

nv :: NVa ::=                                     {{ com numerical values: }} 
  | 0                          ::   :: Zero       {{ com zero value }}
  | S nv                       ::   :: Succ       {{ com successor value }}

bv :: NVa ::=                                     {{ com boolean values: }} 
  | T                          ::   :: True       {{ com true value }}
  | F                          ::   :: False      {{ com false value }}

v :: Va ::=                                       {{ com values: }}
  | 0                          ::   :: Zero       
  | S nv                       ::   :: Succ       
  | T                          ::   :: True
  | F                          ::   :: False
%   | nv
  

subrules
nv <:: v
v <:: t

defns 
Jop :: '' ::= 

defn 
t --> t' :: :: red :: E_ {{ com Evaluation }} by

t1 --> t1'
-------------------- :: Succ
S t1 --> S t1'

------------ :: PredZero
P 0 --> 0

--------------------- :: PredSucc
P (S v1) --> v1 

t1 --> t1'
-------------------- :: Pred
P t1 --> P t1'


-------------------- :: CondTrue
T ? t2 : t3 --> t2

-------------------- :: CondFalse
F ? t2 : t3 --> t3


t1 --> t1'
-------------------- :: Cond
t1 ? t2 : t3 --> t1' ? t2 : t3


-------------------- :: IsEvenZero
iseven 0 --> T


-------------------- :: IsEvenSucc
iseven S nv --> not (iseven nv)


t1 --> t1'
-------------------- :: IsEvenFalse
iseven t --> iseven t1'





% grammar
% term, t :: 't_' ::=                          {{ com term    }}
%     | ( t )                         :: M :: Paren     {{ ich [[t]] }}
%     % I had to import ( t ) from examples/tapl/common.ott. Without it, P_S_cancel complains.
%     | Z            ::   :: zero
%     | S t          ::   :: S     {{ icho [[t]] }}
%     | P t          ::   :: P     {{ icho [[t]] }}
% %   | x            ::   :: var                   {{ com variable}}
% %   | \ x . t      ::   :: lam (+ bind x in t +) {{ com lambda  }}
% %   | t t'         ::   :: app                   {{ com app     }}
% %   | ( t )        :: S :: paren                 {{ icho [[t]]  }}  {{ lem [[t]] }}
% %   | { t / x } t' :: M :: sub  
% %                          {{ icho (tsubst_term [[t]] [[x]] [[t']])}}
% %   {{ lem (tsubst_term [[t]] [[x]] [[t']]) }}
% val,v :: 'v_' ::=                            {{ com values:   }}
%     | Z         :: :: zero                   {{ com zero value }}
%     | S v       :: :: S                   {{ com successor value }}

% terminals :: 'terminals_' ::=
% %   | \            ::   :: lambda  {{ tex \lambda }}
%   | -->          ::   :: red     {{ tex \longrightarrow }}

% subrules
%   val <:: term

% % substitutions
% %   single term var :: tsubst 

% defns
% Jop :: '' ::=

%  defn
%  t1 --> t2 :: ::reduce::'' {{ com $[[t1]]$ reduces to $[[t2]]$ }} {{ lemwcf  witness type reduce_witness; check reduce_check; eval : input -> output }} by


%     % --------------------------  :: ax_app
%     % (\x.t1) v2 -->  {v2/x}t1

%     t1 --> t1'
%     -------------- :: S_cong
%     S t1 --> S t1'

%     -------------- :: prec_zero
%     P Z --> Z

%     -------------- :: P_S_cancel
%     P (S v1) --> v1

%     t1 --> t1'
%     -------------- :: P_cong
%     P t1 --> P t1'


